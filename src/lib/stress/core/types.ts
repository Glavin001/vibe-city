import type RAPIER from '@dimforge/rapier3d-compat';
import type { ColliderDesc } from '@dimforge/rapier3d-compat';
import type { ExtStressSolver, StressRuntime } from 'blast-stress-solver';
export type Vec3 = { x: number; y: number; z: number };

export type SingleCollisionMode =
  | 'all'
  | 'noSinglePairs'
  | 'singleGround'
  | 'singleNone';

/**
 * Mode for when optimization features should be applied:
 * - 'off': Disabled
 * - 'always': Always enabled
 * - 'afterGroundCollision': Only enabled after the body has collided with the ground
 */
export type OptimizationMode = 'off' | 'always' | 'afterGroundCollision';

export type SmallBodyDampingOptions = {
  /** When to apply small body damping (default: 'always') */
  mode?: OptimizationMode;
  /** Maximum collider count to be considered a "small body" (default: 3) */
  colliderCountThreshold?: number;
  /** Minimum linear damping to apply to small bodies (default: 2) */
  minLinearDamping?: number;
  /** Minimum angular damping to apply to small bodies (default: 2) */
  minAngularDamping?: number;
};

export type SleepThresholdOptions = {
  /** When to apply sleep thresholds (default: 'always') */
  mode?: OptimizationMode;
  /** Linear velocity threshold for sleeping (m/s) */
  linear?: number;
  /** Angular velocity threshold for sleeping (rad/s) */
  angular?: number;
};

// Builder that returns a Rapier collider descriptor for a node.
// Static Rapier import is required by callers; this type reuses Rapier's own types.
export type ColliderDescBuilder = () => ColliderDesc | null;

export type ScenarioNode = {
  centroid: Vec3;
  mass: number; // 0 => support
  volume: number;
};

export type ScenarioBond = {
  node0: number;
  node1: number;
  centroid: Vec3;
  normal: Vec3;
  area: number;
};

export type ScenarioDesc = {
  nodes: ScenarioNode[];
  bonds: ScenarioBond[];
  gridCoordinates?: Array<{ ix: number; iy: number; iz: number }>;
  spacing?: Vec3;
  parameters?: Record<string, unknown>;
  // Optional per-node collider descriptors (one entry per node index). If omitted or entry returns null,
  // the core falls back to a box collider sized from the node (nodeSize).
  colliderDescForNode?: Array<ColliderDescBuilder | null>;
};

export type ChunkData = {
  nodeIndex: number;
  size: Vec3;
  isSupport: boolean;
  baseLocalOffset: Vec3;
  localOffset: Vec3;
  colliderHandle: number | null;
  bodyHandle: number | null;
  active: boolean;
  detached: boolean;
  // Damage/health tracking for damageable chunks feature
  maxHealth?: number;
  health?: number;
  pendingDamage?: number;
  destroyed?: boolean;
  baseWorldPosition?: Vec3;
};

export type ProjectileSpawn = {
  x: number;
  z: number;
  type: 'ball' | 'box';
  radius: number;
  mass: number;
  linvelY?: number;
  start?: Vec3;
  linvel?: Vec3;
  friction: number;
  restitution: number;
};

export type ProjectileState = {
  bodyHandle: number;
  radius: number;
  type: 'ball' | 'box';
  spawnTime: number;
  mesh?: unknown;
};

export type BondRef = {
  index: number;
  node0: number;
  node1: number;
  area: number;
  centroid: Vec3;
  normal: Vec3;
};

export type CoreProfilerPass = {
  durationMs: number;
  type: 'initial' | 'resim';
  reasons: string[];
};

export type CoreProfilerSample = {
  frameIndex: number;
  timestamp: number;
  dt: number;
  rapierStepMs: number;
  contactDrainMs: number;
  solverUpdateMs: number;
  damageReplayMs: number;
  damagePreviewMs: number;
  damageTickMs: number;
  fractureMs: number;
  fractureGenerateMs: number;
  fractureApplyMs: number;
  splitQueueMs: number;
  bodyCreateMs: number;
  colliderRebuildMs: number;
  cleanupDisabledMs: number;
  spawnMs: number;
  externalForceMs: number;
  damageSnapshotMs: number;
  damageRestoreMs: number;
  damagePreDestroyMs: number;
  damageFlushMs: number;
  preStepSweepMs: number;
  rebuildColliderMapMs: number;
  projectileCleanupMs: number;
  initialPassMs: number;
  resimMs: number;
  totalMs: number;
  resimPasses: number;
  resimReasons: string[];
  snapshotBytes: number;
  snapshotCaptureMs: number;
  snapshotRestoreMs: number;
  bufferedExternalContacts: number;
  bufferedInternalContacts: number;
  pendingExternalForces: number;
  projectiles: number;
  rigidBodies: number;
  passes: CoreProfilerPass[];
  // Extended stats (optional)
  splitChildCounts?: number[];
  splitPlannerMs?: number;
  bodyCount?: number;
  bodyColliderCountMin?: number | null;
  bodyColliderCountMax?: number | null;
  bodyColliderCountAvg?: number | null;
  bodyColliderCountMedian?: number | null;
  bodyColliderCountP95?: number | null;
};

export type SplitChild = {
  actorIndex: number;
  nodes: number[];
  isSupport: boolean;
};

export type CoreProfilerConfig = {
  enabled: boolean;
  onSample?: (sample: CoreProfilerSample) => void;
};

export type DestructibleCore = {
  world: RAPIER.World;
  eventQueue: RAPIER.EventQueue;
  solver: ExtStressSolver;
  runtime: StressRuntime;
  rootBodyHandle: number;
  groundBodyHandle: number;
  gravity: number;
  chunks: ChunkData[];
  colliderToNode: Map<number, number>;
  actorMap: Map<number, { bodyHandle: number }>;
  // Internal step control handled by core
  step: (dtOverride?: number) => void;
  projectiles: Array<{
    bodyHandle: number;
    radius: number;
    type: 'ball' | 'box';
    mesh?: unknown;
    spawnTime: number;
  }>;
  enqueueProjectile: (s: ProjectileSpawn) => void;
  stepEventful: (dtOverride?: number) => void;
  stepSafe: (dtOverride?: number) => void;
  setGravity: (g: number) => void;
  setSolverGravityEnabled: (v: boolean) => void;
  setSingleCollisionMode: (mode: SingleCollisionMode) => void;
  getRigidBodyCount: () => number;
  getActiveBondsCount: () => number;
  getSolverDebugLines: () => Array<{ p0: Vec3; p1: Vec3; color0: number; color1: number }>;
  // Bond interaction helpers
  getNodeBonds: (nodeIndex: number) => BondRef[];
  cutBond: (bondIndex: number) => boolean;
  cutNodeBonds: (nodeIndex: number) => boolean;
  // External force application (non-contact force injection)
  applyExternalForce: (nodeIndex: number, worldPoint: Vec3, worldForce: Vec3) => void;
  setSleepThresholds?: (linear: number, angular: number) => void;
  setSleepMode?: (mode: OptimizationMode) => void;
  getSleepSettings?: () => SleepThresholdOptions;
  // Small body damping API - apply higher damping to bodies with few colliders
  setSmallBodyDamping?: (opts: SmallBodyDampingOptions) => void;
  getSmallBodyDampingSettings?: () => SmallBodyDampingOptions & { mode: OptimizationMode };
  // Query ground collision status for a body
  hasBodyCollidedWithGround?: (bodyHandle: number) => boolean;
  // Damageable chunks API (present when damage is enabled)
  applyNodeDamage?: (nodeIndex: number, amount: number, reason?: string) => void;
  getNodeHealth?: (nodeIndex: number) => { health: number; maxHealth: number; destroyed: boolean } | null;
  damageEnabled?: boolean;
  dispose: () => void;
  setProfiler: (config: CoreProfilerConfig | null) => void;
  recordProjectileCleanupDuration?: (durationMs: number) => void;
};


